-- JSON_EXISTS
SELECT JSON_EXISTS(NULL::jsonb, '$');
 ?column? 
----------
 
(1 row)

SELECT JSON_EXISTS(jsonb '[]', '$');
 ?column? 
----------
 t
(1 row)

SELECT JSON_EXISTS(JSON_OBJECT(RETURNING jsonb), '$');
 ?column? 
----------
 t
(1 row)

SELECT JSON_EXISTS(jsonb '1', '$');
 ?column? 
----------
 t
(1 row)

SELECT JSON_EXISTS(jsonb 'null', '$');
 ?column? 
----------
 t
(1 row)

SELECT JSON_EXISTS(jsonb '[]', '$');
 ?column? 
----------
 t
(1 row)

SELECT JSON_EXISTS(jsonb '1', '$.a');
 ?column? 
----------
 f
(1 row)

SELECT JSON_EXISTS(jsonb '1', 'strict $.a');
 ?column? 
----------
 f
(1 row)

SELECT JSON_EXISTS(jsonb '1', 'strict $.a' ERROR ON ERROR);
ERROR:  SQL/JSON member not found
SELECT JSON_EXISTS(jsonb 'null', '$.a');
 ?column? 
----------
 f
(1 row)

SELECT JSON_EXISTS(jsonb '[]', '$.a');
 ?column? 
----------
 f
(1 row)

SELECT JSON_EXISTS(jsonb '[1, "aaa", {"a": 1}]', 'strict $.a');
 ?column? 
----------
 f
(1 row)

SELECT JSON_EXISTS(jsonb '[1, "aaa", {"a": 1}]', 'lax $.a');
 ?column? 
----------
 t
(1 row)

SELECT JSON_EXISTS(jsonb '{}', '$.a');
 ?column? 
----------
 f
(1 row)

SELECT JSON_EXISTS(jsonb '{"b": 1, "a": 2}', '$.a');
 ?column? 
----------
 t
(1 row)

SELECT JSON_EXISTS(jsonb '1', '$.a.b');
 ?column? 
----------
 f
(1 row)

SELECT JSON_EXISTS(jsonb '{"a": {"b": 1}}', '$.a.b');
 ?column? 
----------
 t
(1 row)

SELECT JSON_EXISTS(jsonb '{"a": 1, "b": 2}', '$.a.b');
 ?column? 
----------
 f
(1 row)

SELECT JSON_EXISTS(jsonb '{"a": 1, "b": 2}', '$.* ? (@ > $x)' PASSING 1 AS x);
 ?column? 
----------
 t
(1 row)

SELECT JSON_EXISTS(jsonb '{"a": 1, "b": 2}', '$.* ? (@ > $x)' PASSING '1' AS x);
 ?column? 
----------
 f
(1 row)

SELECT JSON_EXISTS(jsonb '{"a": 1, "b": 2}', '$.* ? (@ > $x && @ < $y)' PASSING 0 AS x, 2 AS y);
 ?column? 
----------
 t
(1 row)

SELECT JSON_EXISTS(jsonb '{"a": 1, "b": 2}', '$.* ? (@ > $x && @ < $y)' PASSING 0 AS x, 1 AS y);
 ?column? 
----------
 f
(1 row)

-- extension: boolean expressions
SELECT JSON_EXISTS(jsonb '1', '$ > 2');
 ?column? 
----------
 t
(1 row)

SELECT JSON_EXISTS(jsonb '1', '$.a > 2' ERROR ON ERROR);
 ?column? 
----------
 t
(1 row)

-- JSON_VALUE
SELECT JSON_VALUE(NULL::jsonb, '$');
 ?column? 
----------
 
(1 row)

SELECT JSON_VALUE(jsonb 'null', '$');
 ?column? 
----------
 
(1 row)

SELECT JSON_VALUE(jsonb 'null', '$' RETURNING int);
 ?column? 
----------
         
(1 row)

SELECT JSON_VALUE(jsonb 'true', '$');
 ?column? 
----------
 true
(1 row)

SELECT JSON_VALUE(jsonb 'true', '$' RETURNING bool);
 ?column? 
----------
 t
(1 row)

SELECT JSON_VALUE(jsonb '123', '$');
 ?column? 
----------
 123
(1 row)

SELECT JSON_VALUE(jsonb '123', '$' RETURNING int) + 234;
 ?column? 
----------
      357
(1 row)

SELECT JSON_VALUE(jsonb '123', '$' RETURNING text);
 ?column? 
----------
 123
(1 row)

/* jsonb bytea ??? */
SELECT JSON_VALUE(jsonb '123', '$' RETURNING bytea);
 ?column? 
----------
 \x313233
(1 row)

SELECT JSON_VALUE(jsonb '1.23', '$');
 ?column? 
----------
 1.23
(1 row)

SELECT JSON_VALUE(jsonb '1.23', '$' RETURNING int);
 ?column? 
----------
        1
(1 row)

SELECT JSON_VALUE(jsonb '"1.23"', '$' RETURNING numeric);
 ?column? 
----------
     1.23
(1 row)

SELECT JSON_VALUE(jsonb '"1.23"', '$' RETURNING int ERROR ON ERROR);
ERROR:  invalid input syntax for integer: "1.23"
SELECT JSON_VALUE(jsonb '"aaa"', '$');
 ?column? 
----------
 "aaa"
(1 row)

SELECT JSON_VALUE(jsonb '"aaa"', '$' RETURNING text);
 ?column? 
----------
 aaa
(1 row)

SELECT JSON_VALUE(jsonb '"aaa"', '$' RETURNING char(5));
 ?column? 
----------
 aaa  
(1 row)

SELECT JSON_VALUE(jsonb '"aaa"', '$' RETURNING char(2));
 ?column? 
----------
 
(1 row)

SELECT JSON_VALUE(jsonb '"aaa"', '$' RETURNING json);
 ?column? 
----------
 "aaa"
(1 row)

SELECT JSON_VALUE(jsonb '"aaa"', '$' RETURNING jsonb);
 ?column? 
----------
 "aaa"
(1 row)

SELECT JSON_VALUE(jsonb '"aaa"', '$' RETURNING json ERROR ON ERROR);
 ?column? 
----------
 "aaa"
(1 row)

SELECT JSON_VALUE(jsonb '"aaa"', '$' RETURNING jsonb ERROR ON ERROR);
 ?column? 
----------
 "aaa"
(1 row)

SELECT JSON_VALUE(jsonb '"\"aaa\""', '$' RETURNING json);
 ?column?  
-----------
 "\"aaa\""
(1 row)

SELECT JSON_VALUE(jsonb '"\"aaa\""', '$' RETURNING jsonb);
 ?column?  
-----------
 "\"aaa\""
(1 row)

SELECT JSON_VALUE(jsonb '"aaa"', '$' RETURNING int);
 ?column? 
----------
         
(1 row)

SELECT JSON_VALUE(jsonb '"aaa"', '$' RETURNING int ERROR ON ERROR);
ERROR:  invalid input syntax for integer: "aaa"
SELECT JSON_VALUE(jsonb '"aaa"', '$' RETURNING int DEFAULT 111 ON ERROR);
 ?column? 
----------
      111
(1 row)

SELECT JSON_VALUE(jsonb '"123"', '$' RETURNING int) + 234;
 ?column? 
----------
      357
(1 row)

SELECT JSON_VALUE(jsonb '"2017-02-20"', '$' RETURNING date) + 9;
  ?column?  
------------
 03-01-2017
(1 row)

-- Test NULL checks execution in domain types
CREATE DOMAIN sqljsonb_int_not_null AS int NOT NULL;
SELECT JSON_VALUE(jsonb '1', '$.a' RETURNING sqljsonb_int_not_null);
ERROR:  domain sqljsonb_int_not_null does not allow null values
SELECT JSON_VALUE(jsonb '1', '$.a' RETURNING sqljsonb_int_not_null NULL ON ERROR);
ERROR:  domain sqljsonb_int_not_null does not allow null values
SELECT JSON_VALUE(jsonb '1', '$.a' RETURNING sqljsonb_int_not_null DEFAULT NULL ON ERROR);
ERROR:  domain sqljsonb_int_not_null does not allow null values
SELECT JSON_VALUE(jsonb '[]', '$');
 ?column? 
----------
 
(1 row)

SELECT JSON_VALUE(jsonb '[]', '$' ERROR ON ERROR);
ERROR:  SQL/JSON scalar required
SELECT JSON_VALUE(jsonb '{}', '$');
 ?column? 
----------
 
(1 row)

SELECT JSON_VALUE(jsonb '{}', '$' ERROR ON ERROR);
ERROR:  SQL/JSON scalar required
SELECT JSON_VALUE(jsonb '1', '$.a');
 ?column? 
----------
 
(1 row)

SELECT JSON_VALUE(jsonb '1', 'strict $.a' ERROR ON ERROR);
ERROR:  SQL/JSON member not found
SELECT JSON_VALUE(jsonb '1', 'lax $.a' ERROR ON ERROR);
 ?column? 
----------
 
(1 row)

SELECT JSON_VALUE(jsonb '1', 'lax $.a' ERROR ON EMPTY ERROR ON ERROR);
ERROR:  no SQL/JSON item
SELECT JSON_VALUE(jsonb '1', '$.a' DEFAULT 2 ON ERROR);
ERROR:  cannot cast DEFAULT expression type integer to jsonb
LINE 1: SELECT JSON_VALUE(jsonb '1', '$.a' DEFAULT 2 ON ERROR);
                                                   ^
SELECT JSON_VALUE(jsonb '1', 'lax $.a' DEFAULT 2 ON ERROR);
ERROR:  cannot cast DEFAULT expression type integer to jsonb
LINE 1: SELECT JSON_VALUE(jsonb '1', 'lax $.a' DEFAULT 2 ON ERROR);
                                                       ^
SELECT JSON_VALUE(jsonb '1', 'lax $.a' DEFAULT '2' ON ERROR);
 ?column? 
----------
 
(1 row)

SELECT JSON_VALUE(jsonb '1', 'lax $.a' NULL ON EMPTY DEFAULT '2' ON ERROR);
 ?column? 
----------
 
(1 row)

SELECT JSON_VALUE(jsonb '1', 'lax $.a' DEFAULT '2' ON EMPTY DEFAULT '3' ON ERROR);
 ?column? 
----------
 2
(1 row)

SELECT JSON_VALUE(jsonb '1', 'lax $.a' ERROR ON EMPTY DEFAULT '3' ON ERROR);
 ?column? 
----------
 3
(1 row)

SELECT JSON_VALUE(jsonb '[1,2]', '$[*]' ERROR ON ERROR);
ERROR:  more than one SQL/JSON item
SELECT JSON_VALUE(jsonb '[1,2]', '$[*]' DEFAULT '0' ON ERROR);
 ?column? 
----------
 0
(1 row)

SELECT JSON_VALUE(jsonb '[" "]', '$[*]' RETURNING int ERROR ON ERROR);
ERROR:  invalid input syntax for integer: " "
SELECT JSON_VALUE(jsonb '[" "]', '$[*]' RETURNING int DEFAULT 2 + 3 ON ERROR);
 ?column? 
----------
        5
(1 row)

SELECT JSON_VALUE(jsonb '["1"]', '$[*]' RETURNING int DEFAULT 2 + 3 ON ERROR);
 ?column? 
----------
        1
(1 row)

SELECT
	x,
	JSON_VALUE(
		jsonb '{"a": 1, "b": 2}',
		'$.* ? (@ > $x)' PASSING x AS x
		RETURNING int
		DEFAULT -1 ON EMPTY
		DEFAULT -2 ON ERROR
	) y
FROM
	generate_series(0, 2) x;
 x | y  
---+----
 0 | -2
 1 |  2
 2 | -1
(3 rows)

SELECT JSON_VALUE(jsonb 'null', '$a' PASSING point ' (1, 2 )' AS a);
 ?column? 
----------
 "(1,2)"
(1 row)

SELECT JSON_VALUE(jsonb 'null', '$a' PASSING point ' (1, 2 )' AS a RETURNING point);
 ?column? 
----------
 (1,2)
(1 row)

-- JSON_QUERY
SELECT
	JSON_QUERY(js, '$'),
	JSON_QUERY(js, '$' WITHOUT WRAPPER),
	JSON_QUERY(js, '$' WITH CONDITIONAL WRAPPER),
	JSON_QUERY(js, '$' WITH UNCONDITIONAL ARRAY WRAPPER),
	JSON_QUERY(js, '$' WITH ARRAY WRAPPER)
FROM
	(VALUES
		(jsonb 'null'),
		('12.3'),
		('true'),
		('"aaa"'),
		('[1, null, "2"]'),
		('{"a": 1, "b": [2]}')
	) foo(js);
      ?column?      |      ?column?      |      ?column?      |       ?column?       |       ?column?       
--------------------+--------------------+--------------------+----------------------+----------------------
 null               | null               | [null]             | [null]               | [null]
 12.3               | 12.3               | [12.3]             | [12.3]               | [12.3]
 true               | true               | [true]             | [true]               | [true]
 "aaa"              | "aaa"              | ["aaa"]            | ["aaa"]              | ["aaa"]
 [1, null, "2"]     | [1, null, "2"]     | [1, null, "2"]     | [[1, null, "2"]]     | [[1, null, "2"]]
 {"a": 1, "b": [2]} | {"a": 1, "b": [2]} | {"a": 1, "b": [2]} | [{"a": 1, "b": [2]}] | [{"a": 1, "b": [2]}]
(6 rows)

SELECT
	JSON_QUERY(js, 'strict $[*]') AS "unspec",
	JSON_QUERY(js, 'strict $[*]' WITHOUT WRAPPER) AS "without",
	JSON_QUERY(js, 'strict $[*]' WITH CONDITIONAL WRAPPER) AS "with cond",
	JSON_QUERY(js, 'strict $[*]' WITH UNCONDITIONAL ARRAY WRAPPER) AS "with uncond",
	JSON_QUERY(js, 'strict $[*]' WITH ARRAY WRAPPER) AS "with"
FROM
	(VALUES
		(jsonb '1'),
		('[]'),
		('[null]'),
		('[12.3]'),
		('[true]'),
		('["aaa"]'),
		('[[1, 2, 3]]'),
		('[{"a": 1, "b": [2]}]'),
		('[1, "2", null, [3]]')
	) foo(js);
       unspec       |      without       |      with cond      |     with uncond      |         with         
--------------------+--------------------+---------------------+----------------------+----------------------
                    |                    |                     |                      | 
                    |                    |                     |                      | 
 null               | null               | [null]              | [null]               | [null]
 12.3               | 12.3               | [12.3]              | [12.3]               | [12.3]
 true               | true               | [true]              | [true]               | [true]
 "aaa"              | "aaa"              | ["aaa"]             | ["aaa"]              | ["aaa"]
 [1, 2, 3]          | [1, 2, 3]          | [1, 2, 3]           | [[1, 2, 3]]          | [[1, 2, 3]]
 {"a": 1, "b": [2]} | {"a": 1, "b": [2]} | {"a": 1, "b": [2]}  | [{"a": 1, "b": [2]}] | [{"a": 1, "b": [2]}]
                    |                    | [1, "2", null, [3]] | [1, "2", null, [3]]  | [1, "2", null, [3]]
(9 rows)

SELECT JSON_QUERY(jsonb '"aaa"', '$' RETURNING text);
 ?column? 
----------
 "aaa"
(1 row)

SELECT JSON_QUERY(jsonb '"aaa"', '$' RETURNING text KEEP QUOTES);
 ?column? 
----------
 "aaa"
(1 row)

SELECT JSON_QUERY(jsonb '"aaa"', '$' RETURNING text KEEP QUOTES ON SCALAR STRING);
 ?column? 
----------
 "aaa"
(1 row)

SELECT JSON_QUERY(jsonb '"aaa"', '$' RETURNING text OMIT QUOTES);
 ?column? 
----------
 aaa
(1 row)

SELECT JSON_QUERY(jsonb '"aaa"', '$' RETURNING text OMIT QUOTES ON SCALAR STRING);
 ?column? 
----------
 aaa
(1 row)

SELECT JSON_QUERY(jsonb '"aaa"', '$' OMIT QUOTES ERROR ON ERROR);
ERROR:  invalid input syntax for type json
DETAIL:  Token "aaa" is invalid.
CONTEXT:  JSON data, line 1: aaa
SELECT JSON_QUERY(jsonb '"aaa"', '$' RETURNING json OMIT QUOTES ERROR ON ERROR);
ERROR:  invalid input syntax for type json
DETAIL:  Token "aaa" is invalid.
CONTEXT:  JSON data, line 1: aaa
SELECT JSON_QUERY(jsonb '"aaa"', '$' RETURNING bytea FORMAT JSON OMIT QUOTES ERROR ON ERROR);
 ?column? 
----------
 \x616161
(1 row)

-- QUOTES behavior should not be specified when WITH WRAPPER used:
-- Should fail
SELECT JSON_QUERY(jsonb '[1]', '$' WITH WRAPPER OMIT QUOTES);
ERROR:  SQL/JSON QUOTES behavior shall not be specified when WITH WRAPPER is used
LINE 1: SELECT JSON_QUERY(jsonb '[1]', '$' WITH WRAPPER OMIT QUOTES)...
                                                        ^
SELECT JSON_QUERY(jsonb '[1]', '$' WITH WRAPPER KEEP QUOTES);
ERROR:  SQL/JSON QUOTES behavior shall not be specified when WITH WRAPPER is used
LINE 1: SELECT JSON_QUERY(jsonb '[1]', '$' WITH WRAPPER KEEP QUOTES)...
                                                        ^
SELECT JSON_QUERY(jsonb '[1]', '$' WITH CONDITIONAL WRAPPER KEEP QUOTES);
ERROR:  SQL/JSON QUOTES behavior shall not be specified when WITH WRAPPER is used
LINE 1: ...N_QUERY(jsonb '[1]', '$' WITH CONDITIONAL WRAPPER KEEP QUOTE...
                                                             ^
SELECT JSON_QUERY(jsonb '[1]', '$' WITH CONDITIONAL WRAPPER OMIT QUOTES);
ERROR:  SQL/JSON QUOTES behavior shall not be specified when WITH WRAPPER is used
LINE 1: ...N_QUERY(jsonb '[1]', '$' WITH CONDITIONAL WRAPPER OMIT QUOTE...
                                                             ^
-- Should succeed
SELECT JSON_QUERY(jsonb '[1]', '$' WITHOUT WRAPPER OMIT QUOTES);
 ?column? 
----------
 [1]
(1 row)

SELECT JSON_QUERY(jsonb '[1]', '$' WITHOUT WRAPPER KEEP QUOTES);
 ?column? 
----------
 [1]
(1 row)

SELECT JSON_QUERY(jsonb '[]', '$[*]');
 ?column? 
----------
 
(1 row)

SELECT JSON_QUERY(jsonb '[]', '$[*]' NULL ON EMPTY);
 ?column? 
----------
 
(1 row)

SELECT JSON_QUERY(jsonb '[]', '$[*]' EMPTY ARRAY ON EMPTY);
 ?column? 
----------
 []
(1 row)

SELECT JSON_QUERY(jsonb '[]', '$[*]' EMPTY OBJECT ON EMPTY);
 ?column? 
----------
 {}
(1 row)

SELECT JSON_QUERY(jsonb '[]', '$[*]' ERROR ON EMPTY);
 ?column? 
----------
 
(1 row)

SELECT JSON_QUERY(jsonb '[]', '$[*]' ERROR ON EMPTY NULL ON ERROR);
 ?column? 
----------
 
(1 row)

SELECT JSON_QUERY(jsonb '[]', '$[*]' ERROR ON EMPTY EMPTY ARRAY ON ERROR);
 ?column? 
----------
 []
(1 row)

SELECT JSON_QUERY(jsonb '[]', '$[*]' ERROR ON EMPTY EMPTY OBJECT ON ERROR);
 ?column? 
----------
 {}
(1 row)

SELECT JSON_QUERY(jsonb '[]', '$[*]' ERROR ON EMPTY ERROR ON ERROR);
ERROR:  no SQL/JSON item
SELECT JSON_QUERY(jsonb '[]', '$[*]' ERROR ON ERROR);
 ?column? 
----------
 
(1 row)

SELECT JSON_QUERY(jsonb '[1,2]', '$[*]' ERROR ON ERROR);
ERROR:  more than one SQL/JSON item
SELECT JSON_QUERY(jsonb '[1,2]', '$' RETURNING json);
 ?column? 
----------
 [1, 2]
(1 row)

SELECT JSON_QUERY(jsonb '[1,2]', '$' RETURNING json FORMAT JSON);
 ?column? 
----------
 [1, 2]
(1 row)

SELECT JSON_QUERY(jsonb '[1,2]', '$' RETURNING jsonb);
 ?column? 
----------
 [1, 2]
(1 row)

SELECT JSON_QUERY(jsonb '[1,2]', '$' RETURNING jsonb FORMAT JSON);
 ?column? 
----------
 [1, 2]
(1 row)

SELECT JSON_QUERY(jsonb '[1,2]', '$' RETURNING text);
 ?column? 
----------
 [1, 2]
(1 row)

SELECT JSON_QUERY(jsonb '[1,2]', '$' RETURNING char(10));
  ?column?  
------------
 [1, 2]    
(1 row)

SELECT JSON_QUERY(jsonb '[1,2]', '$' RETURNING char(3));
 ?column? 
----------
 
(1 row)

SELECT JSON_QUERY(jsonb '[1,2]', '$' RETURNING text FORMAT JSON);
 ?column? 
----------
 [1, 2]
(1 row)

SELECT JSON_QUERY(jsonb '[1,2]', '$' RETURNING bytea);
    ?column?    
----------------
 \x5b312c20325d
(1 row)

SELECT JSON_QUERY(jsonb '[1,2]', '$' RETURNING bytea FORMAT JSON);
    ?column?    
----------------
 \x5b312c20325d
(1 row)

SELECT JSON_QUERY(jsonb '[1,2]', '$[*]' RETURNING bytea EMPTY OBJECT ON ERROR);
 ?column? 
----------
 \x7b7d
(1 row)

SELECT JSON_QUERY(jsonb '[1,2]', '$[*]' RETURNING bytea FORMAT JSON EMPTY OBJECT ON ERROR);
 ?column? 
----------
 \x7b7d
(1 row)

SELECT JSON_QUERY(jsonb '[1,2]', '$[*]' RETURNING json EMPTY OBJECT ON ERROR);
 ?column? 
----------
 {}
(1 row)

SELECT JSON_QUERY(jsonb '[1,2]', '$[*]' RETURNING jsonb EMPTY OBJECT ON ERROR);
 ?column? 
----------
 {}
(1 row)

SELECT
	x, y,
	JSON_QUERY(
		jsonb '[1,2,3,4,5,null]',
		'$[*] ? (@ >= $x && @ <= $y)'
		PASSING x AS x, y AS y
		WITH CONDITIONAL WRAPPER
		EMPTY ARRAY ON EMPTY
	) list
FROM
	generate_series(0, 4) x,
	generate_series(0, 4) y;
 x | y |     list     
---+---+--------------
 0 | 0 | []
 0 | 1 | [1]
 0 | 2 | [1, 2]
 0 | 3 | [1, 2, 3]
 0 | 4 | [1, 2, 3, 4]
 1 | 0 | []
 1 | 1 | [1]
 1 | 2 | [1, 2]
 1 | 3 | [1, 2, 3]
 1 | 4 | [1, 2, 3, 4]
 2 | 0 | []
 2 | 1 | []
 2 | 2 | [2]
 2 | 3 | [2, 3]
 2 | 4 | [2, 3, 4]
 3 | 0 | []
 3 | 1 | []
 3 | 2 | []
 3 | 3 | [3]
 3 | 4 | [3, 4]
 4 | 0 | []
 4 | 1 | []
 4 | 2 | []
 4 | 3 | []
 4 | 4 | [4]
(25 rows)

-- Conversion to record types
CREATE TYPE sqljsonb_rec AS (a int, t text, js json, jb jsonb, jsa json[]);
CREATE TYPE sqljsonb_reca AS (reca sqljsonb_rec[]);
SELECT JSON_QUERY(jsonb '[{"a": 1, "b": "foo", "t": "aaa", "js": [1, "2", {}], "jb": {"x": [1, "2", {}]}},  {"a": 2}]', '$[0]' RETURNING sqljsonb_rec);
                      ?column?                       
-----------------------------------------------------
 (1,aaa,"[1, ""2"", {}]","{""x"": [1, ""2"", {}]}",)
(1 row)

SELECT * FROM unnest((JSON_QUERY(jsonb '{"jsa":  [{"a": 1, "b": ["foo"]}, {"a": 2, "c": {}}, 123]}', '$' RETURNING sqljsonb_rec)).jsa);
         unnest         
------------------------
 {"a": 1, "b": ["foo"]}
 {"a": 2, "c": {}}
 123
(3 rows)

SELECT * FROM unnest((JSON_QUERY(jsonb '{"reca": [{"a": 1, "t": ["foo", []]}, {"a": 2, "jb": [{}, true]}]}', '$' RETURNING sqljsonb_reca)).reca);
 a |      t      | js |     jb     | jsa 
---+-------------+----+------------+-----
 1 | ["foo", []] |    |            | 
 2 |             |    | [{}, true] | 
(2 rows)

-- Conversion to array types
SELECT JSON_QUERY(jsonb '[1,2,null,"3"]', '$[*]' RETURNING int[] WITH WRAPPER);
   ?column?   
--------------
 {1,2,NULL,3}
(1 row)

SELECT * FROM unnest(JSON_QUERY(jsonb '[{"a": 1, "t": ["foo", []]}, {"a": 2, "jb": [{}, true]}]', '$' RETURNING sqljsonb_rec[]));
 a |      t      | js |     jb     | jsa 
---+-------------+----+------------+-----
 1 | ["foo", []] |    |            | 
 2 |             |    | [{}, true] | 
(2 rows)

-- Conversion to domain types
SELECT JSON_QUERY(jsonb '{"a": 1}', '$.a' RETURNING sqljsonb_int_not_null);
 ?column? 
----------
        1
(1 row)

SELECT JSON_QUERY(jsonb '{"a": 1}', '$.b' RETURNING sqljsonb_int_not_null);
ERROR:  domain sqljsonb_int_not_null does not allow null values
-- Test constraints
CREATE TABLE test_jsonb_constraints (
	js text,
	i int,
	x jsonb DEFAULT JSON_QUERY(jsonb '[1,2]', '$[*]' WITH WRAPPER)
	CONSTRAINT test_jsonb_constraint1
		CHECK (js IS JSON)
	CONSTRAINT test_jsonb_constraint2
		CHECK (JSON_EXISTS(js::jsonb, '$.a' PASSING i + 5 AS int, i::text AS txt, array[1,2,3] as arr))
	CONSTRAINT test_jsonb_constraint3
		CHECK (JSON_VALUE(js::jsonb, '$.a' RETURNING int DEFAULT ('12' || i)::int ON EMPTY ERROR ON ERROR) > i)
	CONSTRAINT test_jsonb_constraint4
		CHECK (JSON_QUERY(js::jsonb, '$.a' WITH CONDITIONAL WRAPPER EMPTY OBJECT ON ERROR) < jsonb '[10]')
	CONSTRAINT test_jsonb_constraint5
		CHECK (JSON_QUERY(js::jsonb, '$.a' RETURNING char(5) OMIT QUOTES EMPTY ARRAY ON EMPTY) >  'a')
);
\d test_jsonb_constraints
                                                        Table "public.test_jsonb_constraints"
 Column |  Type   | Collation | Nullable |                                                  Default                                                   
--------+---------+-----------+----------+------------------------------------------------------------------------------------------------------------
 js     | text    |           |          | 
 i      | integer |           |          | 
 x      | jsonb   |           |          | JSON_QUERY('[1, 2]'::jsonb, '$[*]' RETURNING jsonb WITH UNCONDITIONAL WRAPPER NULL ON EMPTY NULL ON ERROR)
Check constraints:
    "test_jsonb_constraint1" CHECK (pg_catalog.json_is_valid(js, 'any'::text, false))
    "test_jsonb_constraint2" CHECK (JSON_EXISTS(js::jsonb, '$."a"' PASSING i + 5 AS int, i::text AS txt, to_jsonb(ARRAY[1, 2, 3]) AS arr FALSE ON ERROR))
    "test_jsonb_constraint3" CHECK ((JSON_VALUE(js::jsonb, '$."a"' RETURNING integer DEFAULT ('12'::text || i)::integer ON EMPTY ERROR ON ERROR)) > i)
    "test_jsonb_constraint4" CHECK ((JSON_QUERY(js::jsonb, '$."a"' RETURNING jsonb WITH CONDITIONAL WRAPPER NULL ON EMPTY EMPTY OBJECT ON ERROR)) < '[10]'::jsonb)
    "test_jsonb_constraint5" CHECK ((JSON_QUERY(js::jsonb, '$."a"' RETURNING character(5) OMIT QUOTES EMPTY ARRAY ON EMPTY NULL ON ERROR)) > 'a'::bpchar)

SELECT check_clause
FROM information_schema.check_constraints
WHERE constraint_name LIKE 'test_jsonb_constraint%';
                                                           check_clause                                                            
-----------------------------------------------------------------------------------------------------------------------------------
 (pg_catalog.json_is_valid(js, 'any'::text, false))
 (JSON_EXISTS((js)::jsonb, '$."a"' PASSING (i + 5) AS int, (i)::text AS txt, to_jsonb(ARRAY[1, 2, 3]) AS arr FALSE ON ERROR))
 ((JSON_VALUE((js)::jsonb, '$."a"' RETURNING integer DEFAULT (('12'::text || i))::integer ON EMPTY ERROR ON ERROR) > i))
 ((JSON_QUERY((js)::jsonb, '$."a"' RETURNING jsonb WITH CONDITIONAL WRAPPER NULL ON EMPTY EMPTY OBJECT ON ERROR) < '[10]'::jsonb))
 ((JSON_QUERY((js)::jsonb, '$."a"' RETURNING character(5) OMIT QUOTES EMPTY ARRAY ON EMPTY NULL ON ERROR) > 'a'::bpchar))
(5 rows)

SELECT adsrc FROM pg_attrdef WHERE adrelid = 'test_jsonb_constraints'::regclass;
                                                   adsrc                                                    
------------------------------------------------------------------------------------------------------------
 JSON_QUERY('[1, 2]'::jsonb, '$[*]' RETURNING jsonb WITH UNCONDITIONAL WRAPPER NULL ON EMPTY NULL ON ERROR)
(1 row)

INSERT INTO test_jsonb_constraints VALUES ('', 1);
ERROR:  new row for relation "test_jsonb_constraints" violates check constraint "test_jsonb_constraint1"
DETAIL:  Failing row contains (, 1, [1, 2]).
INSERT INTO test_jsonb_constraints VALUES ('1', 1);
ERROR:  new row for relation "test_jsonb_constraints" violates check constraint "test_jsonb_constraint2"
DETAIL:  Failing row contains (1, 1, [1, 2]).
INSERT INTO test_jsonb_constraints VALUES ('[]');
ERROR:  new row for relation "test_jsonb_constraints" violates check constraint "test_jsonb_constraint2"
DETAIL:  Failing row contains ([], null, [1, 2]).
INSERT INTO test_jsonb_constraints VALUES ('{"b": 1}', 1);
ERROR:  new row for relation "test_jsonb_constraints" violates check constraint "test_jsonb_constraint2"
DETAIL:  Failing row contains ({"b": 1}, 1, [1, 2]).
INSERT INTO test_jsonb_constraints VALUES ('{"a": 1}', 1);
ERROR:  new row for relation "test_jsonb_constraints" violates check constraint "test_jsonb_constraint3"
DETAIL:  Failing row contains ({"a": 1}, 1, [1, 2]).
INSERT INTO test_jsonb_constraints VALUES ('{"a": 7}', 1);
ERROR:  new row for relation "test_jsonb_constraints" violates check constraint "test_jsonb_constraint5"
DETAIL:  Failing row contains ({"a": 7}, 1, [1, 2]).
INSERT INTO test_jsonb_constraints VALUES ('{"a": 10}', 1);
ERROR:  new row for relation "test_jsonb_constraints" violates check constraint "test_jsonb_constraint4"
DETAIL:  Failing row contains ({"a": 10}, 1, [1, 2]).
DROP TABLE test_jsonb_constraints;
-- JSON_TABLE
-- Should fail (JSON_TABLE can be used only in FROM clause)
SELECT JSON_TABLE('[]', '$');
ERROR:  syntax error at or near "("
LINE 1: SELECT JSON_TABLE('[]', '$');
                         ^
-- Should fail (no columns)
SELECT * FROM JSON_TABLE(NULL, '$' COLUMNS ());
ERROR:  syntax error at or near ")"
LINE 1: SELECT * FROM JSON_TABLE(NULL, '$' COLUMNS ());
                                                    ^
-- NULL => empty table
SELECT * FROM JSON_TABLE(NULL::jsonb, '$' COLUMNS (foo int)) bar;
 foo 
-----
(0 rows)

--
SELECT * FROM JSON_TABLE(jsonb '123', '$'
	COLUMNS (item int PATH '$', foo int)) bar;
 item | foo 
------+-----
  123 |    
(1 row)

-- JSON_TABLE: basic functionality
SELECT *
FROM
	(VALUES
		('1'),
		('[]'),
		('{}'),
		('[1, 1.23, "2", "aaaaaaa", null, false, true, {"aaa": 123}, "[1,2]", "\"str\""]')
	) vals(js)
	LEFT OUTER JOIN
-- JSON_TABLE is implicitly lateral
	JSON_TABLE(
		vals.js::jsonb, 'lax $[*]'
		COLUMNS (
			id FOR ORDINALITY,
			id2 FOR ORDINALITY, -- allowed additional ordinality columns
			"int" int PATH '$',
			"text" text PATH '$',
			"char(4)" char(4) PATH '$',
			"bool" bool PATH '$',
			"numeric" numeric PATH '$',
			js json PATH '$',
			jb jsonb PATH '$',
			jst text    FORMAT JSON  PATH '$',
			jsc char(4) FORMAT JSON  PATH '$',
			jsv varchar(4) FORMAT JSON  PATH '$',
			jsb jsonb FORMAT JSON PATH '$',
			aaa int, -- implicit path '$."aaa"',
			aaa1 int PATH '$.aaa'
		)
	) jt
	ON true;
                                       js                                       | id | id2 | int |  text   | char(4) | bool | numeric |    js     |    jb     |     jst      | jsc  | jsv  |     jsb      | aaa | aaa1 
--------------------------------------------------------------------------------+----+-----+-----+---------+---------+------+---------+-----------+-----------+--------------+------+------+--------------+-----+------
 1                                                                              |  1 |   1 |   1 | 1       | 1       | t    |       1 | 1         | 1         | 1            | 1    | 1    | 1            |     |     
 []                                                                             |    |     |     |         |         |      |         |           |           |              |      |      |              |     |     
 {}                                                                             |  1 |   1 |     |         |         |      |         |           |           | {}           | {}   | {}   | {}           |     |     
 [1, 1.23, "2", "aaaaaaa", null, false, true, {"aaa": 123}, "[1,2]", "\"str\""] |  1 |   1 |   1 | 1       | 1       | t    |       1 | 1         | 1         | 1            | 1    | 1    | 1            |     |     
 [1, 1.23, "2", "aaaaaaa", null, false, true, {"aaa": 123}, "[1,2]", "\"str\""] |  2 |   2 |   1 | 1.23    | 1.23    |      |    1.23 | 1.23      | 1.23      | 1.23         | 1.23 | 1.23 | 1.23         |     |     
 [1, 1.23, "2", "aaaaaaa", null, false, true, {"aaa": 123}, "[1,2]", "\"str\""] |  3 |   3 |   2 | 2       | 2       |      |       2 | "2"       | "2"       | "2"          | "2"  | "2"  | "2"          |     |     
 [1, 1.23, "2", "aaaaaaa", null, false, true, {"aaa": 123}, "[1,2]", "\"str\""] |  4 |   4 |     | aaaaaaa |         |      |         | "aaaaaaa" | "aaaaaaa" | "aaaaaaa"    |      |      | "aaaaaaa"    |     |     
 [1, 1.23, "2", "aaaaaaa", null, false, true, {"aaa": 123}, "[1,2]", "\"str\""] |  5 |   5 |     |         |         |      |         |           |           | null         | null | null | null         |     |     
 [1, 1.23, "2", "aaaaaaa", null, false, true, {"aaa": 123}, "[1,2]", "\"str\""] |  6 |   6 |   0 | false   |         | f    |         | false     | false     | false        |      |      | false        |     |     
 [1, 1.23, "2", "aaaaaaa", null, false, true, {"aaa": 123}, "[1,2]", "\"str\""] |  7 |   7 |   1 | true    | true    | t    |         | true      | true      | true         | true | true | true         |     |     
 [1, 1.23, "2", "aaaaaaa", null, false, true, {"aaa": 123}, "[1,2]", "\"str\""] |  8 |   8 |     |         |         |      |         |           |           | {"aaa": 123} |      |      | {"aaa": 123} | 123 |  123
 [1, 1.23, "2", "aaaaaaa", null, false, true, {"aaa": 123}, "[1,2]", "\"str\""] |  9 |   9 |     | [1,2]   |         |      |         | "[1,2]"   | "[1,2]"   | "[1,2]"      |      |      | "[1,2]"      |     |     
 [1, 1.23, "2", "aaaaaaa", null, false, true, {"aaa": 123}, "[1,2]", "\"str\""] | 10 |  10 |     | "str"   |         |      |         | "\"str\"" | "\"str\"" | "\"str\""    |      |      | "\"str\""    |     |     
(13 rows)

-- JSON_TABLE: Test backward parsing
CREATE VIEW jsonb_table_view AS
SELECT * FROM
	JSON_TABLE(
		jsonb 'null', 'lax $[*]' PASSING 1 + 2 AS a, json '"foo"' AS "b c"
		COLUMNS (
			id FOR ORDINALITY,
			id2 FOR ORDINALITY, -- allowed additional ordinality columns
			"int" int PATH '$',
			"text" text PATH '$',
			"char(4)" char(4) PATH '$',
			"bool" bool PATH '$',
			"numeric" numeric PATH '$',
			js json PATH '$',
			jb jsonb PATH '$',
			jst text    FORMAT JSON  PATH '$',
			jsc char(4) FORMAT JSON  PATH '$',
			jsv varchar(4) FORMAT JSON  PATH '$',
			jsb jsonb   FORMAT JSON PATH '$',
			aaa int, -- implicit path '$."aaa"',
			aaa1 int PATH '$.aaa',
			NESTED PATH '$[1]' AS p1 COLUMNS (
				a1 int,
				NESTED PATH '$[*]' AS "p1 1" COLUMNS (
					a11 text
				),
				b1 text
			),
			NESTED PATH '$[2]' AS p2 COLUMNS (
				NESTED PATH '$[*]' AS "p2:1" COLUMNS (
					a21 text
				),
				NESTED PATH '$[*]' AS p22 COLUMNS (
					a22 text
				)
			)
		)
	);
\sv jsonb_table_view
CREATE OR REPLACE VIEW public.jsonb_table_view AS
 SELECT "json_table".id,
    "json_table".id2,
    "json_table"."int",
    "json_table".text,
    "json_table"."char(4)",
    "json_table".bool,
    "json_table"."numeric",
    "json_table".js,
    "json_table".jb,
    "json_table".jst,
    "json_table".jsc,
    "json_table".jsv,
    "json_table".jsb,
    "json_table".aaa,
    "json_table".aaa1,
    "json_table".a1,
    "json_table".b1,
    "json_table".a11,
    "json_table".a21,
    "json_table".a22
   FROM JSON_TABLE(
            'null'::jsonb, '$[*]' AS json_table_path_1
            PASSING
                1 + 2 AS a,
                '"foo"'::json::jsonb AS "b c"
            COLUMNS (
                id FOR ORDINALITY,
                id2 FOR ORDINALITY,
                "int" integer PATH '$',
                text text PATH '$',
                "char(4)" character(4) PATH '$',
                bool boolean PATH '$',
                "numeric" numeric PATH '$',
                js json PATH '$',
                jb jsonb PATH '$',
                jst text FORMAT JSON PATH '$',
                jsc character(4) FORMAT JSON PATH '$',
                jsv character varying(4) FORMAT JSON PATH '$',
                jsb jsonb FORMAT JSON PATH '$',
                aaa integer PATH '$."aaa"',
                aaa1 integer PATH '$."aaa"',
                NESTED PATH '$[1]' AS p1
                COLUMNS (
                    a1 integer PATH '$."a1"',
                    b1 text PATH '$."b1"',
                    NESTED PATH '$[*]' AS "p1 1"
                    COLUMNS (
                        a11 text PATH '$."a11"'
                    )
                ),
                NESTED PATH '$[2]' AS p2
                COLUMNS (
                    NESTED PATH '$[*]' AS "p2:1"
                    COLUMNS (
                        a21 text PATH '$."a21"'
                    ),
                    NESTED PATH '$[*]' AS p22
                    COLUMNS (
                        a22 text PATH '$."a22"'
                    )
                )
            )
            PLAN (json_table_path_1 OUTER ((p1 OUTER "p1 1") UNION (p2 OUTER ("p2:1" UNION p22))))
        )
EXPLAIN (COSTS OFF, VERBOSE) SELECT * FROM jsonb_table_view;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                              QUERY PLAN                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Table Function Scan on "json_table"
   Output: "json_table".id, "json_table".id2, "json_table"."int", "json_table".text, "json_table"."char(4)", "json_table".bool, "json_table"."numeric", "json_table".js, "json_table".jb, "json_table".jst, "json_table".jsc, "json_table".jsv, "json_table".jsb, "json_table".aaa, "json_table".aaa1, "json_table".a1, "json_table".b1, "json_table".a11, "json_table".a21, "json_table".a22
   Table Function Call: JSON_TABLE('null'::jsonb, '$[*]' AS json_table_path_1 PASSING 3 AS a, '"foo"'::jsonb AS "b c" COLUMNS (id FOR ORDINALITY, id2 FOR ORDINALITY, "int" integer PATH '$', text text PATH '$', "char(4)" character(4) PATH '$', bool boolean PATH '$', "numeric" numeric PATH '$', js json PATH '$', jb jsonb PATH '$', jst text FORMAT JSON PATH '$', jsc character(4) FORMAT JSON PATH '$', jsv character varying(4) FORMAT JSON PATH '$', jsb jsonb FORMAT JSON PATH '$', aaa integer PATH '$."aaa"', aaa1 integer PATH '$."aaa"', NESTED PATH '$[1]' AS p1 COLUMNS (a1 integer PATH '$."a1"', b1 text PATH '$."b1"', NESTED PATH '$[*]' AS "p1 1" COLUMNS (a11 text PATH '$."a11"')), NESTED PATH '$[2]' AS p2 COLUMNS ( NESTED PATH '$[*]' AS "p2:1" COLUMNS (a21 text PATH '$."a21"'), NESTED PATH '$[*]' AS p22 COLUMNS (a22 text PATH '$."a22"'))) PLAN (json_table_path_1 OUTER ((p1 OUTER "p1 1") UNION (p2 OUTER ("p2:1" UNION p22)))))
(3 rows)

-- JSON_TABLE: ON EMPTY/ON ERROR behavior
SELECT *
FROM
	(VALUES ('1'), ('"err"')) vals(js),
	JSON_TABLE(vals.js::jsonb, '$' COLUMNS (a int PATH '$')) jt;
  js   | a 
-------+---
 1     | 1
 "err" |  
(2 rows)

SELECT *
FROM
	(VALUES ('1'), ('"err"')) vals(js)
		LEFT OUTER JOIN
	JSON_TABLE(vals.js::jsonb, '$' COLUMNS (a int PATH '$') ERROR ON ERROR) jt
		ON true;
ERROR:  invalid input syntax for integer: "err"
SELECT *
FROM
	(VALUES ('1'), ('"err"')) vals(js)
		LEFT OUTER JOIN
	JSON_TABLE(vals.js::jsonb, '$' COLUMNS (a int PATH '$' ERROR ON ERROR)) jt
		ON true;
ERROR:  invalid input syntax for integer: "err"
SELECT * FROM JSON_TABLE(jsonb '1', '$' COLUMNS (a int PATH '$.a' ERROR ON EMPTY)) jt;
 a 
---
  
(1 row)

SELECT * FROM JSON_TABLE(jsonb '1', '$' COLUMNS (a int PATH 'strict $.a' ERROR ON EMPTY) ERROR ON ERROR) jt;
ERROR:  SQL/JSON member not found
SELECT * FROM JSON_TABLE(jsonb '1', '$' COLUMNS (a int PATH 'lax $.a' ERROR ON EMPTY) ERROR ON ERROR) jt;
ERROR:  no SQL/JSON item
SELECT * FROM JSON_TABLE(jsonb '"a"', '$' COLUMNS (a int PATH '$'   DEFAULT 1 ON EMPTY DEFAULT 2 ON ERROR)) jt;
 a 
---
 2
(1 row)

SELECT * FROM JSON_TABLE(jsonb '"a"', '$' COLUMNS (a int PATH 'strict $.a' DEFAULT 1 ON EMPTY DEFAULT 2 ON ERROR)) jt;
 a 
---
 2
(1 row)

SELECT * FROM JSON_TABLE(jsonb '"a"', '$' COLUMNS (a int PATH 'lax $.a' DEFAULT 1 ON EMPTY DEFAULT 2 ON ERROR)) jt;
 a 
---
 1
(1 row)

-- JSON_TABLE: nested paths and plans
-- Should fail (JSON_TABLE columns shall contain explicit AS path
-- specifications if explicit PLAN clause is used)
SELECT * FROM JSON_TABLE(
	jsonb '[]', '$' -- AS <path name> required here
	COLUMNS (
		foo int PATH '$'
	)
	PLAN DEFAULT (UNION)
) jt;
ERROR:  invalid JSON_TABLE expression
LINE 2:  jsonb '[]', '$' 
         ^
DETAIL:  JSON_TABLE columns shall contain explicit AS pathname specification if explicit PLAN clause is used
SELECT * FROM JSON_TABLE(
	jsonb '[]', '$' AS path1
	COLUMNS (
		NESTED PATH '$' COLUMNS ( -- AS <path name> required here
			foo int PATH '$'
		)
	)
	PLAN DEFAULT (UNION)
) jt;
ERROR:  invalid JSON_TABLE expression
LINE 4:   NESTED PATH '$' COLUMNS ( 
          ^
DETAIL:  JSON_TABLE columns shall contain explicit AS pathname specification if explicit PLAN clause is used
-- Should fail (column names anf path names shall be distinct)
SELECT * FROM JSON_TABLE(
	jsonb '[]', '$' AS a
	COLUMNS (
		a int
	)
) jt;
ERROR:  duplicate JSON_TABLE column name: a
HINT:  JSON_TABLE path names and column names shall be distinct from one another
SELECT * FROM JSON_TABLE(
	jsonb '[]', '$' AS a
	COLUMNS (
		b int,
		NESTED PATH '$' AS a
		COLUMNS (
			c int
		)
	)
) jt;
ERROR:  duplicate JSON_TABLE column name: a
HINT:  JSON_TABLE path names and column names shall be distinct from one another
SELECT * FROM JSON_TABLE(
	jsonb '[]', '$'
	COLUMNS (
		b int,
		NESTED PATH '$' AS b
		COLUMNS (
			c int
		)
	)
) jt;
ERROR:  duplicate JSON_TABLE column name: b
HINT:  JSON_TABLE path names and column names shall be distinct from one another
SELECT * FROM JSON_TABLE(
	jsonb '[]', '$'
	COLUMNS (
		NESTED PATH '$' AS a
		COLUMNS (
			b int
		),
		NESTED PATH '$'
		COLUMNS (
			NESTED PATH '$' AS a
			COLUMNS (
				c int
			)
		)
	)
) jt;
ERROR:  duplicate JSON_TABLE column name: a
HINT:  JSON_TABLE path names and column names shall be distinct from one another
-- JSON_TABLE: plan validation
SELECT * FROM JSON_TABLE(
	jsonb 'null', '$[*]' AS p0
	COLUMNS (
		NESTED PATH '$' AS p1 COLUMNS (
			NESTED PATH '$' AS p11 COLUMNS ( foo int ),
			NESTED PATH '$' AS p12 COLUMNS ( bar int )
		),
		NESTED PATH '$' AS p2 COLUMNS (
			NESTED PATH '$' AS p21 COLUMNS ( baz int )
		)
	)
	PLAN (p1)
) jt;
ERROR:  invalid JSON_TABLE plan
LINE 12:  PLAN (p1)
                ^
DETAIL:  path name mismatch: expected p0 but p1 is given
SELECT * FROM JSON_TABLE(
	jsonb 'null', '$[*]' AS p0
	COLUMNS (
		NESTED PATH '$' AS p1 COLUMNS (
			NESTED PATH '$' AS p11 COLUMNS ( foo int ),
			NESTED PATH '$' AS p12 COLUMNS ( bar int )
		),
		NESTED PATH '$' AS p2 COLUMNS (
			NESTED PATH '$' AS p21 COLUMNS ( baz int )
		)
	)
	PLAN (p0)
) jt;
ERROR:  invalid JSON_TABLE plan
LINE 4:   NESTED PATH '$' AS p1 COLUMNS (
          ^
DETAIL:  plan node for nested path p1 was not found in plan
SELECT * FROM JSON_TABLE(
	jsonb 'null', '$[*]' AS p0
	COLUMNS (
		NESTED PATH '$' AS p1 COLUMNS (
			NESTED PATH '$' AS p11 COLUMNS ( foo int ),
			NESTED PATH '$' AS p12 COLUMNS ( bar int )
		),
		NESTED PATH '$' AS p2 COLUMNS (
			NESTED PATH '$' AS p21 COLUMNS ( baz int )
		)
	)
	PLAN (p0 OUTER p3)
) jt;
ERROR:  invalid JSON_TABLE plan
LINE 4:   NESTED PATH '$' AS p1 COLUMNS (
          ^
DETAIL:  plan node for nested path p1 was not found in plan
SELECT * FROM JSON_TABLE(
	jsonb 'null', '$[*]' AS p0
	COLUMNS (
		NESTED PATH '$' AS p1 COLUMNS (
			NESTED PATH '$' AS p11 COLUMNS ( foo int ),
			NESTED PATH '$' AS p12 COLUMNS ( bar int )
		),
		NESTED PATH '$' AS p2 COLUMNS (
			NESTED PATH '$' AS p21 COLUMNS ( baz int )
		)
	)
	PLAN (p0 OUTER (p1 CROSS p13))
) jt;
ERROR:  invalid JSON_TABLE plan
LINE 8:   NESTED PATH '$' AS p2 COLUMNS (
          ^
DETAIL:  plan node for nested path p2 was not found in plan
SELECT * FROM JSON_TABLE(
	jsonb 'null', '$[*]' AS p0
	COLUMNS (
		NESTED PATH '$' AS p1 COLUMNS (
			NESTED PATH '$' AS p11 COLUMNS ( foo int ),
			NESTED PATH '$' AS p12 COLUMNS ( bar int )
		),
		NESTED PATH '$' AS p2 COLUMNS (
			NESTED PATH '$' AS p21 COLUMNS ( baz int )
		)
	)
	PLAN (p0 OUTER (p1 CROSS p2))
) jt;
ERROR:  invalid JSON_TABLE plan
LINE 5:    NESTED PATH '$' AS p11 COLUMNS ( foo int ),
           ^
DETAIL:  plan node for nested path p11 was not found in plan
SELECT * FROM JSON_TABLE(
	jsonb 'null', '$[*]' AS p0
	COLUMNS (
		NESTED PATH '$' AS p1 COLUMNS (
			NESTED PATH '$' AS p11 COLUMNS ( foo int ),
			NESTED PATH '$' AS p12 COLUMNS ( bar int )
		),
		NESTED PATH '$' AS p2 COLUMNS (
			NESTED PATH '$' AS p21 COLUMNS ( baz int )
		)
	)
	PLAN (p0 OUTER ((p1 UNION p11) CROSS p2))
) jt;
ERROR:  invalid JSON_TABLE plan
LINE 12:  PLAN (p0 OUTER ((p1 UNION p11) CROSS p2))
                         ^
DETAIL:  plan node contains some extra or duplicate sibling nodes
SELECT * FROM JSON_TABLE(
	jsonb 'null', '$[*]' AS p0
	COLUMNS (
		NESTED PATH '$' AS p1 COLUMNS (
			NESTED PATH '$' AS p11 COLUMNS ( foo int ),
			NESTED PATH '$' AS p12 COLUMNS ( bar int )
		),
		NESTED PATH '$' AS p2 COLUMNS (
			NESTED PATH '$' AS p21 COLUMNS ( baz int )
		)
	)
	PLAN (p0 OUTER ((p1 INNER p11) CROSS p2))
) jt;
ERROR:  invalid JSON_TABLE plan
LINE 6:    NESTED PATH '$' AS p12 COLUMNS ( bar int )
           ^
DETAIL:  plan node for nested path p12 was not found in plan
SELECT * FROM JSON_TABLE(
	jsonb 'null', '$[*]' AS p0
	COLUMNS (
		NESTED PATH '$' AS p1 COLUMNS (
			NESTED PATH '$' AS p11 COLUMNS ( foo int ),
			NESTED PATH '$' AS p12 COLUMNS ( bar int )
		),
		NESTED PATH '$' AS p2 COLUMNS (
			NESTED PATH '$' AS p21 COLUMNS ( baz int )
		)
	)
	PLAN (p0 OUTER ((p1 INNER (p12 CROSS p11)) CROSS p2))
) jt;
ERROR:  invalid JSON_TABLE plan
LINE 9:    NESTED PATH '$' AS p21 COLUMNS ( baz int )
           ^
DETAIL:  plan node for nested path p21 was not found in plan
SELECT * FROM JSON_TABLE(
	jsonb 'null', 'strict $[*]' AS p0
	COLUMNS (
		NESTED PATH '$' AS p1 COLUMNS (
			NESTED PATH '$' AS p11 COLUMNS ( foo int ),
			NESTED PATH '$' AS p12 COLUMNS ( bar int )
		),
		NESTED PATH '$' AS p2 COLUMNS (
			NESTED PATH '$' AS p21 COLUMNS ( baz int )
		)
	)
	PLAN (p0 OUTER ((p1 INNER (p12 CROSS p11)) CROSS (p2 INNER p21)))
) jt;
 bar | foo | baz 
-----+-----+-----
(0 rows)

SELECT * FROM JSON_TABLE(
	jsonb 'null', 'strict $[*]' -- without root path name
	COLUMNS (
		NESTED PATH '$' AS p1 COLUMNS (
			NESTED PATH '$' AS p11 COLUMNS ( foo int ),
			NESTED PATH '$' AS p12 COLUMNS ( bar int )
		),
		NESTED PATH '$' AS p2 COLUMNS (
			NESTED PATH '$' AS p21 COLUMNS ( baz int )
		)
	)
	PLAN ((p1 INNER (p12 CROSS p11)) CROSS (p2 INNER p21))
) jt;
 bar | foo | baz 
-----+-----+-----
(0 rows)

-- JSON_TABLE: plan execution
CREATE TEMP TABLE jsonb_table_test (js jsonb);
INSERT INTO jsonb_table_test
VALUES (
	'[
		{"a":  1,  "b": [], "c": []},
		{"a":  2,  "b": [1, 2, 3], "c": [10, null, 20]},
		{"a":  3,  "b": [1, 2], "c": []}, 
		{"x": "4", "b": [1, 2], "c": 123}
	 ]'
);
-- unspecified plan (outer, union)
select
	jt.*
from
	jsonb_table_test jtt,
	json_table (
		jtt.js,'strict $[*]' as p
		columns (
			n for ordinality,
			a int path 'lax $.a' default -1 on empty,
			nested path 'strict $.b[*]' as pb columns ( b int path '$' ),
			nested path 'strict $.c[*]' as pc columns ( c int path '$' )
		)
	) jt;
 n | a  | b | c  
---+----+---+----
 1 |  1 |   |   
 2 |  2 | 1 |   
 2 |  2 | 2 |   
 2 |  2 | 3 |   
 2 |  2 |   | 10
 2 |  2 |   |   
 2 |  2 |   | 20
 3 |  3 | 1 |   
 3 |  3 | 2 |   
 4 | -1 | 1 |   
 4 | -1 | 2 |   
(11 rows)

-- default plan (outer, union)
select
	jt.*
from
	jsonb_table_test jtt,
	json_table (
		jtt.js,'strict $[*]' as p
		columns (
			n for ordinality,
			a int path 'lax $.a' default -1 on empty,
			nested path 'strict $.b[*]' as pb columns ( b int path '$' ),
			nested path 'strict $.c[*]' as pc columns ( c int path '$' )
		)
		plan default (outer, union)
	) jt;
 n | a  | b | c  
---+----+---+----
 1 |  1 |   |   
 2 |  2 | 1 |   
 2 |  2 | 2 |   
 2 |  2 | 3 |   
 2 |  2 |   | 10
 2 |  2 |   |   
 2 |  2 |   | 20
 3 |  3 | 1 |   
 3 |  3 | 2 |   
 4 | -1 | 1 |   
 4 | -1 | 2 |   
(11 rows)

-- specific plan (p outer (pb union pc))
select
	jt.*
from
	jsonb_table_test jtt,
	json_table (
		jtt.js,'strict $[*]' as p
		columns (
			n for ordinality,
			a int path 'lax $.a' default -1 on empty,
			nested path 'strict $.b[*]' as pb columns ( b int path '$' ),
			nested path 'strict $.c[*]' as pc columns ( c int path '$' )
		)
		plan (p outer (pb union pc))
	) jt;
 n | a  | b | c  
---+----+---+----
 1 |  1 |   |   
 2 |  2 | 1 |   
 2 |  2 | 2 |   
 2 |  2 | 3 |   
 2 |  2 |   | 10
 2 |  2 |   |   
 2 |  2 |   | 20
 3 |  3 | 1 |   
 3 |  3 | 2 |   
 4 | -1 | 1 |   
 4 | -1 | 2 |   
(11 rows)

-- specific plan (p outer (pc union pb))
select
	jt.*
from
	jsonb_table_test jtt,
	json_table (
		jtt.js,'strict $[*]' as p
		columns (
			n for ordinality,
			a int path 'lax $.a' default -1 on empty,
			nested path 'strict $.b[*]' as pb columns ( b int path '$' ),
			nested path 'strict $.c[*]' as pc columns ( c int path '$' )
		)
		plan (p outer (pc union pb))
	) jt;
 n | a  | c  | b 
---+----+----+---
 1 |  1 |    |  
 2 |  2 | 10 |  
 2 |  2 |    |  
 2 |  2 | 20 |  
 2 |  2 |    | 1
 2 |  2 |    | 2
 2 |  2 |    | 3
 3 |  3 |    | 1
 3 |  3 |    | 2
 4 | -1 |    | 1
 4 | -1 |    | 2
(11 rows)

-- default plan (inner, union)
select
	jt.*
from
	jsonb_table_test jtt,
	json_table (
		jtt.js,'strict $[*]' as p
		columns (
			n for ordinality,
			a int path 'lax $.a' default -1 on empty,
			nested path 'strict $.b[*]' as pb columns ( b int path '$' ),
			nested path 'strict $.c[*]' as pc columns ( c int path '$' )
		)
		plan default (inner)
	) jt;
 n | a  | b | c  
---+----+---+----
 2 |  2 | 1 |   
 2 |  2 | 2 |   
 2 |  2 | 3 |   
 2 |  2 |   | 10
 2 |  2 |   |   
 2 |  2 |   | 20
 3 |  3 | 1 |   
 3 |  3 | 2 |   
 4 | -1 | 1 |   
 4 | -1 | 2 |   
(10 rows)

-- specific plan (p inner (pb union pc))
select
	jt.*
from
	jsonb_table_test jtt,
	json_table (
		jtt.js,'strict $[*]' as p
		columns (
			n for ordinality,
			a int path 'lax $.a' default -1 on empty,
			nested path 'strict $.b[*]' as pb columns ( b int path '$' ),
			nested path 'strict $.c[*]' as pc columns ( c int path '$' )
		)
		plan (p inner (pb union pc))
	) jt;
 n | a  | b | c  
---+----+---+----
 2 |  2 | 1 |   
 2 |  2 | 2 |   
 2 |  2 | 3 |   
 2 |  2 |   | 10
 2 |  2 |   |   
 2 |  2 |   | 20
 3 |  3 | 1 |   
 3 |  3 | 2 |   
 4 | -1 | 1 |   
 4 | -1 | 2 |   
(10 rows)

-- default plan (inner, cross)
select
	jt.*
from
	jsonb_table_test jtt,
	json_table (
		jtt.js,'strict $[*]' as p
		columns (
			n for ordinality,
			a int path 'lax $.a' default -1 on empty,
			nested path 'strict $.b[*]' as pb columns ( b int path '$' ),
			nested path 'strict $.c[*]' as pc columns ( c int path '$' )
		)
		plan default (cross, inner)
	) jt;
 n | a | b | c  
---+---+---+----
 2 | 2 | 1 | 10
 2 | 2 | 1 |   
 2 | 2 | 1 | 20
 2 | 2 | 2 | 10
 2 | 2 | 2 |   
 2 | 2 | 2 | 20
 2 | 2 | 3 | 10
 2 | 2 | 3 |   
 2 | 2 | 3 | 20
(9 rows)

-- specific plan (p inner (pb cross pc))
select
	jt.*
from
	jsonb_table_test jtt,
	json_table (
		jtt.js,'strict $[*]' as p
		columns (
			n for ordinality,
			a int path 'lax $.a' default -1 on empty,
			nested path 'strict $.b[*]' as pb columns ( b int path '$' ),
			nested path 'strict $.c[*]' as pc columns ( c int path '$' )
		)
		plan (p inner (pb cross pc))
	) jt;
 n | a | b | c  
---+---+---+----
 2 | 2 | 1 | 10
 2 | 2 | 1 |   
 2 | 2 | 1 | 20
 2 | 2 | 2 | 10
 2 | 2 | 2 |   
 2 | 2 | 2 | 20
 2 | 2 | 3 | 10
 2 | 2 | 3 |   
 2 | 2 | 3 | 20
(9 rows)

-- default plan (outer, cross)
select
	jt.*
from
	jsonb_table_test jtt,
	json_table (
		jtt.js,'strict $[*]' as p
		columns (
			n for ordinality,
			a int path 'lax $.a' default -1 on empty,
			nested path 'strict $.b[*]' as pb columns ( b int path '$' ),
			nested path 'strict $.c[*]' as pc columns ( c int path '$' )
		)
		plan default (outer, cross)
	) jt;
 n | a  | b | c  
---+----+---+----
 1 |  1 |   |   
 2 |  2 | 1 | 10
 2 |  2 | 1 |   
 2 |  2 | 1 | 20
 2 |  2 | 2 | 10
 2 |  2 | 2 |   
 2 |  2 | 2 | 20
 2 |  2 | 3 | 10
 2 |  2 | 3 |   
 2 |  2 | 3 | 20
 3 |  3 |   |   
 4 | -1 |   |   
(12 rows)

-- specific plan (p outer (pb cross pc))
select
	jt.*
from
	jsonb_table_test jtt,
	json_table (
		jtt.js,'strict $[*]' as p
		columns (
			n for ordinality,
			a int path 'lax $.a' default -1 on empty,
			nested path 'strict $.b[*]' as pb columns ( b int path '$' ),
			nested path 'strict $.c[*]' as pc columns ( c int path '$' )
		)
		plan (p outer (pb cross pc))
	) jt;
 n | a  | b | c  
---+----+---+----
 1 |  1 |   |   
 2 |  2 | 1 | 10
 2 |  2 | 1 |   
 2 |  2 | 1 | 20
 2 |  2 | 2 | 10
 2 |  2 | 2 |   
 2 |  2 | 2 | 20
 2 |  2 | 3 | 10
 2 |  2 | 3 |   
 2 |  2 | 3 | 20
 3 |  3 |   |   
 4 | -1 |   |   
(12 rows)

select
	jt.*, b1 + 100 as b
from
	json_table (jsonb
		'[
			{"a":  1,  "b": [[1, 10], [2], [3, 30, 300]], "c": [1, null, 2]},
			{"a":  2,  "b": [10, 20], "c": [1, null, 2]}, 
			{"x": "3", "b": [11, 22, 33, 44]}
		 ]', 
		'$[*]' as p
		columns (
			n for ordinality,
			a int path 'lax $.a' default -1 on error,
			nested path 'strict $.b[*]' as pb columns (
				b text format json path '$', 
				nested path 'strict $[*]' as pb1 columns (
					b1 int path '$'
				)
			),
			nested path 'strict $.c[*]' as pc columns (
				c text format json path '$',
				nested path 'strict $[*]' as pc1 columns (
					c1 int path '$'
				)
			)
		)
		--plan default(outer, cross)
		plan(p outer ((pb inner pb1) cross (pc outer pc1)))
	) jt;
 n | a |      b       | b1  |  c   | c1 |  b  
---+---+--------------+-----+------+----+-----
 1 | 1 | [1, 10]      |   1 | 1    |    | 101
 1 | 1 | [1, 10]      |   1 | null |    | 101
 1 | 1 | [1, 10]      |   1 | 2    |    | 101
 1 | 1 | [1, 10]      |  10 | 1    |    | 110
 1 | 1 | [1, 10]      |  10 | null |    | 110
 1 | 1 | [1, 10]      |  10 | 2    |    | 110
 1 | 1 | [2]          |   2 | 1    |    | 102
 1 | 1 | [2]          |   2 | null |    | 102
 1 | 1 | [2]          |   2 | 2    |    | 102
 1 | 1 | [3, 30, 300] |   3 | 1    |    | 103
 1 | 1 | [3, 30, 300] |   3 | null |    | 103
 1 | 1 | [3, 30, 300] |   3 | 2    |    | 103
 1 | 1 | [3, 30, 300] |  30 | 1    |    | 130
 1 | 1 | [3, 30, 300] |  30 | null |    | 130
 1 | 1 | [3, 30, 300] |  30 | 2    |    | 130
 1 | 1 | [3, 30, 300] | 300 | 1    |    | 400
 1 | 1 | [3, 30, 300] | 300 | null |    | 400
 1 | 1 | [3, 30, 300] | 300 | 2    |    | 400
 2 | 2 |              |     |      |    |    
 3 |   |              |     |      |    |    
(20 rows)

-- Should succeed (JSON arguments are passed to root and nested paths)
SELECT *
FROM
	generate_series(1, 4) x,
	generate_series(1, 3) y,
	JSON_TABLE(jsonb
		'[[1,2,3],[2,3,4,5],[3,4,5,6]]',
		'strict $[*] ? (@.[*] < $x)'
		PASSING x AS x, y AS y
		COLUMNS (
			y text FORMAT JSON PATH '$',
			NESTED PATH 'strict $[*] ? (@ >= $y)'
			COLUMNS (
				z int PATH '$'
			)
		)
	) jt;
 x | y |      y       | z 
---+---+--------------+---
 2 | 1 | [1, 2, 3]    | 1
 2 | 1 | [1, 2, 3]    | 2
 2 | 1 | [1, 2, 3]    | 3
 3 | 1 | [1, 2, 3]    | 1
 3 | 1 | [1, 2, 3]    | 2
 3 | 1 | [1, 2, 3]    | 3
 3 | 1 | [2, 3, 4, 5] | 2
 3 | 1 | [2, 3, 4, 5] | 3
 3 | 1 | [2, 3, 4, 5] | 4
 3 | 1 | [2, 3, 4, 5] | 5
 4 | 1 | [1, 2, 3]    | 1
 4 | 1 | [1, 2, 3]    | 2
 4 | 1 | [1, 2, 3]    | 3
 4 | 1 | [2, 3, 4, 5] | 2
 4 | 1 | [2, 3, 4, 5] | 3
 4 | 1 | [2, 3, 4, 5] | 4
 4 | 1 | [2, 3, 4, 5] | 5
 4 | 1 | [3, 4, 5, 6] | 3
 4 | 1 | [3, 4, 5, 6] | 4
 4 | 1 | [3, 4, 5, 6] | 5
 4 | 1 | [3, 4, 5, 6] | 6
 2 | 2 | [1, 2, 3]    | 2
 2 | 2 | [1, 2, 3]    | 3
 3 | 2 | [1, 2, 3]    | 2
 3 | 2 | [1, 2, 3]    | 3
 3 | 2 | [2, 3, 4, 5] | 2
 3 | 2 | [2, 3, 4, 5] | 3
 3 | 2 | [2, 3, 4, 5] | 4
 3 | 2 | [2, 3, 4, 5] | 5
 4 | 2 | [1, 2, 3]    | 2
 4 | 2 | [1, 2, 3]    | 3
 4 | 2 | [2, 3, 4, 5] | 2
 4 | 2 | [2, 3, 4, 5] | 3
 4 | 2 | [2, 3, 4, 5] | 4
 4 | 2 | [2, 3, 4, 5] | 5
 4 | 2 | [3, 4, 5, 6] | 3
 4 | 2 | [3, 4, 5, 6] | 4
 4 | 2 | [3, 4, 5, 6] | 5
 4 | 2 | [3, 4, 5, 6] | 6
 2 | 3 | [1, 2, 3]    | 3
 3 | 3 | [1, 2, 3]    | 3
 3 | 3 | [2, 3, 4, 5] | 3
 3 | 3 | [2, 3, 4, 5] | 4
 3 | 3 | [2, 3, 4, 5] | 5
 4 | 3 | [1, 2, 3]    | 3
 4 | 3 | [2, 3, 4, 5] | 3
 4 | 3 | [2, 3, 4, 5] | 4
 4 | 3 | [2, 3, 4, 5] | 5
 4 | 3 | [3, 4, 5, 6] | 3
 4 | 3 | [3, 4, 5, 6] | 4
 4 | 3 | [3, 4, 5, 6] | 5
 4 | 3 | [3, 4, 5, 6] | 6
(52 rows)

-- Should fail (JSON arguments are not passed to column paths)
SELECT *
FROM JSON_TABLE(
	jsonb '[1,2,3]',
	'$[*] ? (@ < $x)'
		PASSING 10 AS x
		COLUMNS (y text FORMAT JSON PATH '$ ? (@ < $x)')
	) jt;
ERROR:  could not find 'x' passed variable
